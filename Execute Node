// https://www.reddit.com/r/Kos/comments/3mslqe/suicide_burn/
// https://pastebin.com/cwcW62Cm
// https://github.com/marianoapp/kOS-scripts/blob/master/land.ks
// https://www.reddit.com/r/Kos/comments/3fq4is/a_script_to_get_information_on_stages_in_advance/
// https://pastebin.com/6ga862mt

CLEARSCREEN.
SET config:ipu TO 300.
SET terminal:height TO 20.
SET terminal:width TO 40.

FUNCTION burn_info {
    PARAMETER dV.
    LOCAL i IS 0.
    LOCAL s IS list_stages.
    LOCAL burndV IS 0.
    LOCAL burnTime IS 0.
    LOCAL checkMean IS TRUE.
    LOCAL meanTime IS 0.

    UNTIL burndV >= dV OR i = s:length {
        LOCAL stagedV IS s[i][5].
        LOCAL ve IS 9.80665 * s[i][4].

        IF checkMean AND burndV + stagedV >= dV / 2 {
            LOCAL meanMass IS s[i][0] / constant:e^((dV / 2 - burndV) / ve).
            SET meanTime TO burnTime + (s[i][0] - meanMass) / s[i][3].
            SET checkMean TO FALSE.
        }

        IF burndV + stagedV > dV { SET stagedV TO dV - burndV. }
        LOCAL burnMass IS s[i][0] / constant:e^(stagedV / ve).

        SET burndV TO burndV + stagedV.
        SET burnTime TO burnTime + (s[i][0] - burnMass) / s[i][3] + stageTime * i.

        SET i TO i + 1.
        WAIT 0.
    }

    IF burndV < dV {
        PRINT "Danger!".
        RETURN list(0,0,0).

    } ELSE { RETURN list(burnTime, meanTime, i). }
}

FUNCTION stage_info {
    LOCAL endpart IS ship:rootpart.
    LOCAL list_roots IS list().
    LOCAL list_sections IS list().

    FOR p IN ship:parts {
        IF p:istype("Engine") AND p:stage > endpart:stage { SET endpart TO p. }
        WAIT 0.
    }

    FUNCTION root_search {
        PARAMETER p.
        WAIT 0.

        LOCAL add_root IS FALSE.

        IF p:hasparent {
            IF p:parent:name:contains("EnginePlate") AND NOT p:istype("Engine") { SET add_root TO TRUE. }
            IF p:parent:istype("Engine") AND p:istype("Decoupler") { SET add_root TO TRUE. }

        } ELSE IF NOT p:hasparent { SET add_root TO TRUE. }

        IF add_root {
            LOCAL section IS list().

            list_roots:insert(0, p).

            FUNCTION section_search {
                PARAMETER p.
                WAIT 0.

                section:add(p).

                IF NOT p:children:empty {
                    FOR c IN p:children {
                        IF NOT list_roots:contains(c) { section_search(c). }
                    }
                }
            }
            section_search(list_roots[0]).
            list_sections:insert(0, section).
        }
        IF p:hasparent { root_search(p:parent). }
    }

    root_search(endpart).

    LOCAL i IS 0.
    LOCAL list_stages IS list().
    LOCAL m IS 0.

    UNTIL i = list_sections:length {
        LOCAL section IS list(0,0,0,0,0,0). // mass, drymass, thrust, flow, isp, dV

        FOR p IN list_sections[i] {
            IF p:istype("Engine") AND p:allowshutdown {
                IF section[1] = 0 {
                    LOCAL a IS CHOOSE FALSE IF NOT p:ignition ELSE TRUE.
                    LOCAL n IS 0.

                    IF NOT a { p:activate. }

                    UNTIL n = p:consumedresources:keys:length {
                        LOCAL f IS p:consumedresources:keys[n].
                        WAIT 0.

                        SET section[1] TO section[1] + p:consumedresources[f]:amount * p:consumedresources[f]:density.
                        SET n TO n + 1.
                    }
                    IF NOT a { p:shutdown. }
                }
                SET section[2] TO section[2] + p:possiblethrustat(0).
                SET section[3] TO section[3] + p:possiblethrustat(0) / (9.80665 * p:visp).
                SET section[4] TO section[2] / (9.80665 * section[3]).
            }
            SET m TO m + p:mass.
            WAIT 0.
        }
        SET section[0] TO m.
        SET section[1] TO section[0] - section[1].
        SET section[5] TO (9.80665 * section[4]) * ln(section[0] / section[1]).
        list_stages:insert(0, section).

        SET i TO i + 1.
    }
    RETURN list_stages.
}

// LISTS.
LOCAL list_stages IS stage_info().

// VARIABLES.
LOCAL burnVec IS nextnode:burnvector.
LOCAL maxthrustAtStage IS ship:maxthrustat(0).
LOCAL stageTime IS 1.6.

LOCAL burnInfo IS burn_info(nextnode:deltav:mag).
LOCAL burnTime IS burnInfo[0].
LOCAL meanTime IS burnInfo[1].

LOCAL ve IS 9.80665 * list_stages[0][4].
LOCAL stagedV IS ve * ln(ship:mass / list_stages[0][1]).
LOCAL burnMass IS ship:mass / constant:e^(min(nextnode:deltav:mag, stagedV) / ve).

// SYSTEM CONTROL.
LOCAL modeBurn IS CHOOSE FALSE IF burnTime > 0.001 ELSE TRUE.
LOCAL steeringCtrl IS lookdirup(nextnode:burnvector, facing:topvector).
LOCAL throttleCtrl IS 1.

PRINT " ".
PRINT " Burn time     =".
PRINT " Half time     =".
PRINT " Node ETA      =".
PRINT "--------------------------".
PRINT " ".
PRINT " Node angle    =".
PRINT " Node delta-v  =".
PRINT " Stage delta-v =".
PRINT "--------------------------".

rcs OFF.
sas OFF.
LOCK steering TO steeringCtrl.
LOCK throttle TO 0.

UNTIL sas {

      IF NOT modeBurn AND nextnode:eta <= meanTime {
            SET modeBurn TO TRUE.
            SET burnVec TO nextnode:burnvector.
            LOCK throttle TO throttleCtrl.
      }

      IF burnInfo[2] = 1 {  // Figure out better way to find stages used. // If current_stage_dV < nextnodeLdeltav:mag?
            SET burnInfo TO burn_info(nextnode:deltav:mag).
            SET burnTime TO burnInfo[0].
            SET meanTime TO burnInfo[1].
            SET throttleCtrl TO min(1, burnTime).
      }

      IF maxthrustAtStage > ship:maxthrustat(0) OR maxthrustAtStage = 0 {
            LOCAL t0 IS time:seconds.
            WAIT 1.
            stage.
            WAIT UNTIL stage:ready.
            SET maxthrustAtStage TO ship:maxthrustat(0).

            IF maxthrustAtStage <> 0 {  // Once we have a better way of finding stages used, reduce this?
                  SET list_stages TO stage_info().
                  SET stageTime TO time:seconds - t0.

                  SET burnInfo TO burn_info(nextnode:deltav:mag).
                  SET burnTime TO burnInfo[0].
                  SET meanTime TO burnInfo[1].
            }
      }

      IF throttleCtrl < 1 { SET steeringCtrl TO lookdirup(burnVec, facing:topvector).
      } ELSE { SET steeringCtrl TO lookdirup(nextnode:burnvector, facing:topvector). }

SET ve TO 9.80665 * list_stages[0][4].
SET stagedV TO ve * ln(ship:mass / list_stages[0][1]).
SET burnMass TO ship:mass / constant:e^(min(nextnode:deltav:mag, stagedV) / ve).

      PRINT round(burnTime,3) + "   " + round((ship:mass - burnMass) / list_stages[0][3],3) + "     " at(17,1).
      PRINT round(meanTime,1) + "    " at(17,2).
      PRINT round(nextnode:eta,1) + "    " at(17,3).
      PRINT round(vang(nextnode:burnvector, facing:vector),1) + "    " at(17,6).
      PRINT round(nextnode:deltav:mag,3) + "      " at(17,7).
      PRINT round(stagedV,3) + "      " at(17,8).

      IF modeBurn AND (burnTime < 0.001 OR vang(burnVec, nextnode:burnvector) > 90) { BREAK. }
      // IF modeBurn AND (burnTime <= 0 OR nextnode:deltav:mag < 0.001 OR vang(burnVec, nextnode:burnvector) > 90) { BREAK. }  
      // IF modeBurn AND (nextnode:deltav:mag < 0.001 OR vang(burnVec, nextnode:burnvector) > 90) { BREAK. }

      WAIT 0.
}

SET ship:control:pilotmainthrottle TO 0.
SET throttleCtrl TO 0.
UNLOCK ALL.
sas ON.
