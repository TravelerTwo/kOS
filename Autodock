// Abbreviation         - lowercase, as few letter as possible, preferably matching SI designation (eg. ve, velocity > vel)
// Boolean              - boolCase?, returns either TRUE or FALSE
// Cardinal point       - lowercase_E/N/S/W (eg. vel_E)
// Function             - lowercase_underscore (eg. pitch_angle)
// - that returns list  - lowercase_underscore_info (eg. burn_info)
// - to appreviate      - lowercase_underscore, short and descriptive(eg. dist_to)
// List                 - camelInfo or lex/list_lowercase (eg. burnInfo, lex_axis)
// Parameter            - few (<5) letters representing the parameter (eg. apo, char, inc, p)
// Physical property    - lowercase, as few letter as possible, preferably matching SI designation (eg, b, g, rad)
// - Adjusted
// - Second order
// Relative direction   - down, fore, left, right, star, top, up
// System control       - modeCamel or camelCtrl (eg. modeBurn, steeringCtrl)
// Variable             - camelCase
// - adjusted, corrected- camelCase_corr
// - based on function  - camelCase, same name as function (eg. pitchAngle)
// - iterator counter   - i, j, k OR single letter representation (p = part, s = stage, etc.)

// Component    - camelCase (eg. hAccel, vAccel)
// Geoposition  - G_camelCase (eg. G_site)
// Keyword      - (eg. burn, Mode, nav)
// Position     - P_camelCase
// Target       - T_camelCase (eg. T_apo)
// Target       - burn/navCase (eg. burnApo, navApo)
// Vector       - V_camelCase
// - component  - x/y/z_camelCase

// Acceleration - acc, accel
// Altitude     - alt
// Angle        - ang, angle
// Apoapsis     - apo
// Distance     - dist
// Error        - diff, error
// Limit        - camelCtrl, camelLimit, maxCase, minCase
// Orbit        - orb
// Pitch
// Roll
// Speed
// Surface      - srf
// Time
// Velocity     - vel
// Yaw

CLEARSCREEN.
SET config:ipu TO 600.
SET terminal:height TO 22.
SET terminal:width TO 40.
SET steeringmanager:rollcontrolanglerange TO 90.

IF NOT HASTARGET { PRINT "Select target..." at(0,0). }
WAIT UNTIL HASTARGET.

FUNCTION new_param {
    LOCAL chr IS terminal:input:getchar().

    IF list_num:contains(chr) {
        SET input TO input + chr.
        PRINT input at(15,8).

    } ELSE IF chr = terminal:input:backspace {
        SET input TO "".
        PRINT "       " at(15,8).

    } ELSE IF chr = terminal:input:upcursorone {
        PRINT "  " at(2,9 + i).
        SET i TO i - 1.
        IF i < 0 { SET i TO 2. }

    } ELSE IF chr = terminal:input:downcursorone {
        PRINT "  " at(2,9 + i).
        SET i TO i + 1.
        IF i > 2 { SET i TO 0. }

    } ELSE IF chr = terminal:input:enter {
        IF input <> "" { SET lex_axis[lex_axis:keys[i]] TO input:toscalar. }
        SET input TO "".
        PRINT "       " at(15,8).
    }

    PRINT ">>" at(2,9 + i).
}

FUNCTION RCS_output {
    PARAMETER vec.

    LOCAL RCSAccel IS 1 / ship:mass.
    LOCAL RCSSpeed IS sqrt(max(0, 2 * vec:mag * RCSAccel)).
    LOCAL V_RCS IS (V_velocity + RCSSpeed * vec:normalized) / RCSAccel.

    LOCAL x_RCS IS vdot(facing:starvector, V_RCS).
    LOCAL y_RCS IS vdot(facing:topvector, V_RCS).
    LOCAL z_RCS IS vdot(facing:forevector, V_RCS).

    SET ship:control:translation TO v(x_RCS, y_RCS, z_RCS).
}

FUNCTION dist_info {
    PARAMETER pos.
    LOCAL t IS -target:facing.
    RETURN list(vdot(t:vector, pos), vdot(t:starvector, pos), vdot(t:topvector, pos)).
}

// LISTS.
LOCAL distInfo IS list().
LOCAL lex_axis IS lex("fore", 0, "star", 0, "top", 0).
LOCAL list_num IS list("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-", ".").

// VARIABLES.
LOCAL V_angularVel IS facing:vector.
LOCAL V_position IS facing:vector.
LOCAL V_velocity IS facing:vector.
LOCAL x_position IS facing:vector.
LOCAL y_position IS facing:vector.
LOCAL z_position IS facing:vector.
LOCAL V_position_corr IS x_position + y_position + z_position.

// SYSTEM CONTROL.
LOCAL modeDock IS FALSE.
LOCAL i IS 0.
LOCAL input IS "".
LOCAL steeringCtrl IS facing:vector.

PRINT "                          ".
PRINT " Angle".
PRINT "     PITCH   =".
PRINT "     YAW     =".
PRINT "     ROLL    =".
PRINT " VELOCITY    =".
PRINT "--------------------------".
PRINT " ".
PRINT " Distance".
PRINT "     FORE    =".
PRINT "     STAR    =".
PRINT "     TOP     =".
PRINT "--------------------------".
PRINT " ".
PRINT " Range       =".
PRINT " Range rate  =".
PRINT " Status      = Approaching target".
PRINT "--------------------------".

rcs ON.
sas OFF.
// RCS_output(ship:position).
LOCK steering TO steeringCtrl.

UNTIL NOT HASTARGET OR sas {

      IF NOT modeDock {

            SET distInfo TO dist_info(V_position).
            SET V_position TO target:position.

            IF target:istype("vessel") {
                  SET V_angularVel TO target:angularvel - ship:angularvel.
                  SET V_velocity TO target:velocity:orbit - velocity:orbit.
            }

            SET V_position_corr TO V_position:vec.
            SET V_position_corr:mag TO V_position_corr:mag - max(10, min(V_position:mag, 150)).
            SET steeringCtrl TO V_position.

            PRINT round(distInfo[0]) + "  " at(15,9).
            PRINT round(distInfo[1]) + "  " at(15,10).
            PRINT round(distInfo[2]) + "  " at(15,11).

            IF V_velocity:mag < 0.02 AND V_position:mag < 200 AND rcs {
                  rcs OFF.
                  PRINT "Set control/target ports" at(15,16).

            } ELSE IF V_velocity:mag > 0.2 AND NOT rcs {
                  rcs ON.
                  PRINT "Moving to wait position " at(15,16).
            }

            IF target:istype("part") AND ship:controlpart:targetable {
                  SET lex_axis:star TO distInfo[0].
                  SET lex_axis:top TO distInfo[1].
                  SET lex_axis:fore TO distInfo[2].
                  SET modeDock TO TRUE.
                  rcs ON.
                  PRINT ">>" at(2,9).
                  PRINT "New target  =" at(1,8).
                  PRINT "Manual distance control " at(15,16).
            }

      } ELSE IF modeDock {

            SET V_angularVel TO target:ship:angularvel - ship:angularvel.
            SET V_position TO target:nodeposition - ship:controlpart:nodeposition.
            SET V_velocity TO target:ship:velocity:orbit - velocity:orbit.

            SET x_position TO -target:facing:vector * lex_axis:fore.
            SET y_position TO -target:facing:starvector * lex_axis:star.
            SET z_position TO -target:facing:topvector * lex_axis:top.
            SET V_position_corr TO V_position - (x_position + y_position + z_position).
            SET steeringCtrl TO lookdirup(-target:facing:vector, target:facing:topvector).

            IF terminal:input:haschar { new_param(). }

            PRINT round(lex_axis:fore,2) + "      " at(15,9).
            PRINT round(lex_axis:star,2) + "      " at(15,10).
            PRINT round(lex_axis:top,2) + "      " at(15,11).

            IF NOT target:istype("part") OR NOT ship:controlpart:targetable {
                  SET modeDock TO FALSE.
                  PRINT "Distance     " at(1,8).
                  PRINT "  " at(2,9 + i).
                  PRINT "Approaching target      " at(15,16).
            }
      }

      RCS_output(V_position_corr).

      PRINT round(vang(facing:vector, -target:facing:vector),2) + "    " at(15,2).
      PRINT round(vang(facing:starvector, -target:facing:starvector),2) + "    " at(15,3).
      PRINT round(vang(facing:topvector, target:facing:topvector),2) + "    " at(15,4).
      PRINT round(V_angularVel:mag * constant:radtodeg,2) + "    " at(15,5).
      PRINT round(V_position:mag) + "  " at(15,14).
      PRINT round(V_velocity:mag,2) + "    " at(15,15).

      WAIT 0.
}

SET ship:control:neutralize TO TRUE.
steeringmanager:resettodefault().
UNLOCK ALL.
rcs OFF.
