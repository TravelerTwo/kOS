// Retrograde launch, pitch isn't perfect, but it's working.
// Change name of "rad".

PARAMETER desiredApo IS 100000.
PARAMETER desiredInc IS 0.

CLEARSCREEN.
SET config:ipu TO 600.
SET steeringmanager:rollcontrolanglerange TO 180.
SET steeringmanager:rolltorquefactor TO 0.5.
SET terminal:height TO 25.
SET terminal:width TO 40.
IF HASNODE { REMOVE nextnode. }

FUNCTION burn_dV {
    LOCAL rad IS body:radius + apoapsis.
    LOCAL velApo IS sqrt(body:mu * (2 / rad - 1 / obt:semimajoraxis)).
    LOCAL velCirc IS sqrt(body:mu / rad).
    RETURN velCirc - velApo.
}

FUNCTION launch_azimuth {
    PARAMETER inc.

    LOCAL V_orb IS max(sqrt(body:mu / body:position:mag), velocity:orbit:mag + 1).
    LOCAL az_orb IS arcsin(cos(inc) / cos(ship:latitude)).
    IF inc < 0 { SET az_orb TO 180 - az_orb. }

    LOCAL V_star IS heading(az_orb, 0) * v(0, 0, V_orb).
    LOCAL V_ship_h IS vxcl(up:vector, velocity:orbit).
    LOCAL V_corr IS V_star - V_ship_h.
    LOCAL vel_n IS vdot(V_corr, north:vector).
    LOCAL vel_e IS vdot(V_corr, heading(90, 0):vector).
    LOCAL az_corr IS arctan2(vel_e, vel_n).
    RETURN az_corr.
}

FUNCTION pitch_angle {
    LOCAL offsetApo IS desiredApo * (1 + p + ship:q).
    LOCAL offsetSpeed IS body:atm:height * maxTwr.
    LOCAL speedOrbit IS sqrt(body:mu / (body:radius + offsetSpeed)).
    RETURN sqrt((apoapsis / offsetApo + groundspeed / speedOrbit) / 2) * 90.
}

// LIBRARY.
IF core:currentvolume:files:keys:contains("lib_info") { RUN ONCE lib_info. } ELSE { RUNONCEPATH("0:/lib_info"). }

// LISTS.
LOCAL burnInfo IS list().
LOCAL list_stages IS list().

// PHYSICAL PROPERTIES.
LOCAL g IS body:mu / body:position:sqrmagnitude.
LOCAL p IS body:atm:altitudepressure(altitude).

// VARIABLES.
LOCAL burndV IS burn_dV().
LOCAL burnMass IS 0.
LOCAL burnTime IS 0.
LOCAL burnVec IS facing:vector.
LOCAL maxAccel IS ship:availablethrust / ship:mass.
LOCAL maxthrustAtStage IS ship:maxthrustat(0).
LOCAL navAlt IS 100 + alt:radar.
LOCAL navPitch IS 90.
LOCAL navYaw IS 90.
LOCAL maxTwr IS 1.
LOCAL pitchOrbit IS vang(up:vector, velocity:orbit).
LOCAL stagedV IS 0.
LOCAL ve IS 0.

// SYSTEM CONTROL.
LOCAL modeBurn IS FALSE.
LOCAL modeCirc IS FALSE.
LOCAL modeCoast IS FALSE.
LOCAL steeringCtrl IS lookdirup(facing:vector, facing:topvector).
LOCAL throttleCtrl IS 1.

PRINT " ".
PRINT " Local gravity  =".
PRINT " Local TWR      =".
PRINT " Pressure (ATM) =".
PRINT " Pressure (Q)   =".
PRINT " Throttle       =".
PRINT " ".
PRINT " Eccentricity   =".
PRINT " Relative apo   =".
PRINT " Relative inc   =".
PRINT " Relative pitch =".
PRINT "--------------------------".
PRINT " ".
PRINT " Burn start     =".
PRINT " Burn time      =".
PRINT " Node ETA       =".
PRINT "--------------------------".
PRINT " ".
PRINT " Node angle     =".
PRINT " Node delta-v   =".
PRINT " Stage delta-v  =".
PRINT "--------------------------".

sas OFF.
gear OFF.
brakes OFF.
LOCK steering TO steeringCtrl.
LOCK throttle TO throttleCtrl.

IF desiredApo <= body:atm:height { SET desiredApo TO body:atm:height + 10000. }

IF abs(desiredInc) > 180 - abs(ship:latitude) { SET desiredInc TO 180. }
ELSE IF abs(desiredInc) < abs(ship:latitude) { SET desiredInc TO 0. }

IF desiredInc = 180 { SET navYaw TO 270. }

UNTIL sas {

      IF NOT modeCirc {

            SET navPitch TO 90 - min(pitch_angle(), pitchOrbit).
            SET pitchOrbit TO vang(up:vector, velocity:orbit).
            SET pitchOrbit TO max(pitchOrbit, 90 - pitchOrbit).
            // SET throttleCtrl TO max(0.66, min(1, 60 - eta:apoapsis)) - ship:q^2.
            // IF maxAccel > 0 { SET throttleCtrl TO min(1, (desiredApo - apoapsis) / 10 / maxAccel) - ship:q^2. }
            // IF maxAccel > 0 { SET throttleCtrl TO max(min(0.33, (desiredApo - apoapsis) / 10 / maxAccel), min(1, 60 - eta:apoapsis)) - ship:q^2. }

// IF maxAccel > 0 { SET maxThrot TO (desiredApo - apoapsis) / 10 / maxAccel. }
// SET minThrot TO 60 * obt:eccentricity + 10 - eta:apoapsis.
// SET throttleCtrl TO max(min(0.33, maxThrot), min(1, minThrot)) - ship:q^2.
// SET throttleCtrl TO max(maxThrot, min(1, minThrot)) - ship:q^2.

            IF desiredInc <> 0 AND desiredInc <> 180 { SET navYaw TO launch_azimuth(desiredInc). }
            SET steeringCtrl TO CHOOSE heading(navYaw, navPitch) IF airspeed > 100 AND alt:radar > navAlt ELSE lookdirup(up:vector, facing:topvector).

            PRINT round(p,3) + "     " at(18,3).
            PRINT round(ship:q,3) + "     " at(18,4).
            PRINT round(desiredApo - apoapsis) + "  " at(18,8).
            PRINT round(navPitch - (90 - vang(up:vector, facing:vector)),2) + "    " at(18,10).
            PRINT round(eta:apoapsis,1) + "    " at(18,15).

            IF NOT modeCoast AND apoapsis >= desiredApo - 1 {
                  SET burndV TO burn_dV().
                  SET burnTime TO burndV / maxAccel.
                  SET modeCoast TO TRUE.
                  LOCK throttle TO 0.

                  PRINT round(burnTime,1) + "    " at(18,14).
                  PRINT round(eta:apoapsis,1) + "    " at(18,15).
                  PRINT round(burndV,3) + "      " at(18,19).

                  IF eta:apoapsis < burnTime {
                        SET desiredApo TO desiredApo + 10000.
                        SET modeCoast TO FALSE.
                        LOCK throttle TO throttleCtrl.
                  }

            } ELSE IF modeCoast AND altitude > body:atm:height {
                  SET list_stages TO stage_info().
                  SET modeCirc TO TRUE.
                  SET ve TO 9.80665 * list_stages[0][4].

                  SET burndV TO burn_dV().
                  SET burnInfo TO burn_info(burndV, list_stages).
                  SET burnTime TO burnInfo[0].
                  PRINT round(burnInfo[1],1) + "    " at(18,13).
                  ADD node(time:seconds + eta:apoapsis, 0, 0, burndV).
            }

      } ELSE {

            IF NOT modeBurn AND nextnode:eta <= burnInfo[1] {
                  SET burnVec TO nextnode:burnvector.
                  SET modeBurn TO TRUE.
                  LOCK throttle TO throttleCtrl.
            }

            IF nextnode:deltav:mag < stagedV {
                  SET burnMass TO ship:mass / constant:e^(nextnode:deltav:mag / ve).
                  SET burnTime TO (ship:mass - burnMass) / list_stages[0][3].
            }

            SET stagedV TO ve * ln(ship:mass / list_stages[0][1]).
            SET steeringCtrl TO CHOOSE lookdirup(burnVec, facing:topvector) IF throttleCtrl < 1 ELSE lookdirup(nextnode:burnvector, up:vector).
            SET throttleCtrl TO min(1, burnTime).

            PRINT round(apoapsis - max(0, periapsis)) + "  " at(18,8).
            PRINT round(burnTime,1) + "    " at(18,14).
            PRINT round(nextnode:eta,1) + "    " at(18,15).
            PRINT round(vang(nextnode:burnvector, facing:vector),1) + "    " at(18,18).
            PRINT round(nextnode:deltav:mag,2) + "    " at(18,19).
            PRINT round(stagedV,2) + "    " at(18,20).

            IF burnTime < 0.001 OR modeBurn AND vang(burnVec, nextnode:burnvector) > 90 { BREAK. }
      }

      IF maxthrustAtStage > ship:maxthrustat(0) OR maxthrustAtStage = 0 {
            WAIT 0.4.
            stage.

            WAIT UNTIL stage:ready.
            SET maxthrustAtStage TO ship:maxthrustat(0).

            IF modeCirc AND maxthrustAtStage <> 0 {
                  list_stages:remove(0).
                  SET ve TO 9.80665 * list_stages[0][4].

                  SET burnInfo TO burn_info(burndV, list_stages).
                  SET burnTime TO burnInfo[0].
            }
      }

      SET g TO body:mu / body:position:sqrmagnitude.
      SET p TO body:atm:altitudepressure(altitude).
      SET maxAccel TO ship:availablethrust / ship:mass.
      SET maxTwr TO maxAccel / g.

      PRINT round(g,2) + "    " at(18,1).
      PRINT round(maxTwr,2) + "    " at(18,2).
      PRINT round(throttle,2) + "    " at(18,5).
      PRINT round(obt:eccentricity,4) + "      " at(18,7).
      PRINT round(abs(desiredInc) - obt:inclination,2) + "    " at(18,9).

      WAIT 0.
}

steeringmanager:resettodefault().
SET ship:control:pilotmainthrottle TO 0.
SET throttleCtrl TO 0.
UNLOCK ALL.
rcs OFF.
sas ON.
