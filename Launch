PARAMETER desiredApo IS 100000.
PARAMETER desiredInc IS 0.

// TO-DO.
// Retrograde launch, pitch isn't perfect, but it's working.
// Very low TWR upper stages might need something to help them pitch up to compensate for lack of thrust.
// Azimuth function crashes if desiredInc < ship:latitude for retrograde launch.

// ON HOLD UNTIL STAGE:MASS AND ENGINE:FUELTYPE OR EQUIVALENTS.
// Calculate stage delta-v.
// If stage dV < burnDv { stage. }
// Check next stage TWR.
// Adapt burn_check to use next stage TWR after using whatever dV remains in current stage.

CLEARSCREEN.
SET config:ipu TO 500.
SET steeringmanager:rollcontrolanglerange TO 180.
SET steeringmanager:rolltorquefactor TO 0.5.
SET terminal:height TO 20.
SET terminal:width TO 40.

FUNCTION burn_dV {
    LOCAL velApo IS velocityat(ship, time:seconds + eta:apoapsis):orbit:mag.
    LOCAL velCirc IS sqrt(body:mu / (body:radius + apoapsis)).
    RETURN velCirc - velApo.
}

FUNCTION desired_pitch {
    LOCAL atmPitch IS desiredApo * (1 + p + ship:q).
    // LOCAL spdPitch IS body:atm:height * maxTwr.
    // LOCAL desiredSpeed IS sqrt(body:mu / (body:radius + spdPitch)).
    // LOCAL desiredPitch IS sqrt(apoapsis / atmPitch) + sqrt(groundspeed / desiredSpeed).
    // RETURN desiredPitch / 2 * 90.
    RETURN sqrt(apoapsis / atmPitch) * 90.
}

FUNCTION launch_azimuth {
    PARAMETER inc.

    LOCAL V_orb IS max(sqrt(body:mu / body:position:mag), velocity:orbit:mag + 1).
    LOCAL az_orb IS arcsin(cos(inc) / cos(ship:latitude)).
    IF inc < 0 { SET az_orb TO 180 - az_orb. }

    LOCAL V_star IS heading(az_orb, 0) * v(0, 0, V_orb).
    LOCAL V_ship_h IS vxcl(up:vector, velocity:orbit).
    LOCAL V_corr IS V_star - V_ship_h.
    LOCAL vel_n IS vdot(V_corr, north:vector).
    LOCAL vel_e IS vdot(V_corr, heading(90, 0):vector).
    LOCAL az_corr IS arctan2(vel_e, vel_n).
    RETURN az_corr.
}

// PHYSICAL PROPERTIES.
LOCAL g IS body:mu / body:position:sqrmagnitude.
LOCAL p IS body:atm:altitudepressure(altitude).

// VARIABLES.
LOCAL burndV IS burn_dV().
LOCAL maxAccel IS ship:availablethrust / ship:mass.
LOCAL maxthrustAtStage IS ship:maxthrustat(0).
LOCAL navAlt IS 100 + alt:radar.
LOCAL navPitch IS 90.
LOCAL navYaw IS 90.
LOCAL PIDApo IS PIDLoop(0.75, 1.15, 0.005, 0, 1).
LOCAL pitchCraft IS vang(up:vector, facing:vector).
LOCAL pitchOrbit IS vang(up:vector, velocity:orbit).

LOCAL desiredEta IS burndV / max(0.0001, maxAccel) / 2.
LOCAL maxTwr IS maxAccel / g.
IF desiredApo < body:atm:height { SET desiredApo TO body:atm:height + 10000. }
IF desiredInc = 180 { SET navYaw TO 270. }
IF abs(desiredInc) < abs(ship:latitude) { SET desiredInc TO 0. }

// SYSTEM CONTROL.
LOCAL modeCirc IS FALSE.
LOCAL steeringCtrl IS lookdirup(facing:vector, facing:topvector).
LOCAL throttleCtrl IS 1.

PRINT " ".
PRINT " Local gravity  =".
PRINT " Local TWR      =".
PRINT " Pressure (ATM) =".
PRINT " Pressure (Q)   =".
PRINT " Throttle       =".
PRINT " ".
PRINT " Relative inc   =".
PRINT " Relative pitch =".
PRINT "--------------------------".
PRINT " ".
PRINT " Burn at ETA    =".
PRINT " Eccentricity   =".
PRINT " ".
PRINT " Relative apo   =".
PRINT " Relative ETA   =".
PRINT " Relative speed =".
PRINT "--------------------------".

sas OFF.
gear OFF.
brakes OFF.
LOCK steering TO steeringCtrl.
LOCK throttle TO throttleCtrl.

UNTIL FALSE OR sas {

      IF NOT modeCirc {

            SET navPitch TO 90 - min(desired_pitch(), pitchOrbit).
            SET throttleCtrl TO 1 - ship:q^2.

            IF apoapsis > desiredApo - 2500 {
                  SET modeCirc TO TRUE.
                  SET throttleCtrl TO 0.
            }

      } ELSE {

            SET burndV TO burn_dV().
            SET desiredEta TO burndV / max(0.0001, maxAccel) / 2.
            SET navPitch TO 90 - pitchOrbit.
            SET PIDApo:setpoint TO desiredEta + 1.
            SET throttleCtrl TO PIDApo:update(time:seconds, eta:apoapsis).

            PRINT round(desiredEta,2) + "    " at(18,11).
            PRINT round(obt:eccentricity,2) + "    " at(18,12).
            PRINT round(eta:apoapsis - desiredEta,2) + "    " at(18,15).
            PRINT round(burndV,2) + "    " at(18,16).

            IF burndV < 0.25 { BREAK. }
      }
      
      IF maxthrustAtStage > ship:maxthrustat(0) OR maxthrustAtStage = 0 {
            WAIT 1.
            stage.
            WAIT UNTIL stage:ready.
            SET maxthrustAtStage TO ship:maxthrustat(0).
      }

      IF desiredInc <> 0 AND desiredInc <> 180 { SET navYaw TO launch_azimuth(desiredInc). }

      IF alt:radar > navAlt { SET steeringCtrl TO heading(navYaw, navPitch). }
      ELSE { SET steeringCtrl TO lookdirup(up:vector, facing:topvector). }

      SET g TO body:mu / body:position:sqrmagnitude.
      SET p TO body:atm:altitudepressure(altitude).
      SET maxAccel TO ship:availablethrust / ship:mass.
      SET maxTwr TO maxAccel / g.
      SET pitchCraft TO 90 - vang(up:vector, facing:vector).
      SET pitchOrbit TO vang(up:vector, velocity:orbit).
      SET pitchOrbit TO max(pitchOrbit, 90 - pitchOrbit).

      PRINT round(g,2) + "    " at(18,1).
      PRINT round(maxTwr,2) + "    " at(18,2).
      PRINT round(p,3) + "     " at(18,3).
      PRINT round(ship:q,3) + "     " at(18,4).
      PRINT round(throttleCtrl,2) + "    " at(18,5).
      PRINT round(abs(desiredInc) - obt:inclination,2) + "    " at(18,7).
      PRINT round(navPitch - pitchCraft,2) + "    " at(18,8).
      PRINT round(desiredApo - apoapsis) + "  " at(18,14).

      WAIT 0.
}

steeringmanager:resettodefault().
SET ship:control:pilotmainthrottle TO 0.
SET throttleCtrl TO 0.
UNLOCK ALL.
rcs OFF.
sas ON.
